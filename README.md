# sevenPL

아래의 내용 및 코드는 **Bruce A. Tate, 『Seven Languages in seven weeks**를 바탕으로 함.

### 프로그래밍 모델 

1. 객체지향 **(Ruby, Scala)**
    - 세 개의 중요한 아이디어(캡슐화, 상속, 다형성)을 기반으로 한 패러다임
    - **Ruby**에서 클래스나 객체의 정의를 통해 계약을 규정하는 것이 아닌, 어떤 객체가 실제로 지원하는 메서드에 의해 타이핑을 규정하는 동적인 오리 타이핑 사용
    - **Scala**에서 문법의 간결화를 지원하는 자료형 유추를 사용하여 간결한 프로그래밍 언어 지원
2. 프로토타입 **(Io)**
    - 프로토타입은 클래스가 아닌 객체 인스턴스를 통해 작업 수행
    - 동적 타이핑을 기본으로 사용하며 스크립팅이나 사용자 인터페이스를 중심으로 하는 애플리케이션을 작성할 때 강점을 가짐
3. 제약-논리 프로그래밍 **(Prolog)**
    - 주어진 공간 전체에 대해 알고 있는 논리적 제약을 정의하고, 이를 자동으로 프로그래밍 언어가 수행하는 방식
    - 적은 코드 양으로도 결과를 도출할 수 있다는 장점이 존재함
4. 함수 프로그래밍 **(Scala, Eralng, Clojure, Haskell)**
    - 함수 프로그램은 수학적 함수로 이루어져 있으며, 똑같은 함수를 여러번 호출하는 것은 언제나 같은 결과를 도출함 -> 이를 이용해 함수들을 자유롭게 합성이 가능함
    - 고계함수(함수의 인자로 함수를 넘기거나, 함수를 리턴하는 함수), 커링(다중 인수를 갖는 함수를 단일 인수를 갖는 함수들의 함수열로 바꾸는 것)등의 개념이 존재


### 동시성
- 객체지향 프로그래밍은 부수효과와 변경 가능한 상태를 허용함 (그러나 동시성 프로그램이 너무 복잡해짐)
- 함수 프로그래밍 언어는 중요한 규칙을 통해 구조를 도입함 -> 동일한 함수를 호출해도 결과는 항상 동일함

1. 액터 **(Io, Erlang, Scala)**
    - 객체의 경계를 넘어서는 프로세스 간의 비구조적 통신을 저마다의 메세지 큐를 가지고 있는 액터들 사이에서 이루어지는 구조적인 메세지 통신으로 변형함
2. 퓨처 **(Io)**
    - Io는 액터 모델에 2개의 동시성 구조물이 추가됨
        - 코루틴 : 두 개의 객체가 적당한 시간에 통제를 포기하는 방식으로 서로 협력하면서 멀티태스크를 수행하도록 함
        - 퓨처 : 오랜 시간 동작하는 동시적인 연산을 저장하는 구조물
3. 트랜잭션 메모리 **(Clojure)**
    -  소프트웨어 트랜잭션 메모리(STM)는 공유되는 자원에 대한 분산된 접근을 하나의 트랜잭션 안으로 묶어두는 기능 -> DB는 이와 동일한 방법을 이용해서 여러 동시적 접근이 일어나는 상황에서도 DB의 무결성을 유지함
    - 클로저에서는 애플리케이션의 무결성과 성능이 유지될 것이라고 믿으면서 다양한 프로그래밍 패러다임을 사용하도록 지원됨


### 프로그래밍 구조물

1. 리스트 컴프리헨션 **(Erlang, Clojure, Haskell)**
    - 이는 리스트와 관련된 몇 가지 아이디어를 하나의 구조물 안에 주입시킨 개념으로, 이는 필터, 맵, 카티전 곱 등을 가지고 있음

```haskell
Tax = [{Product, Quantity, Price, Price * Quantity * 0.05} || 
        {Product, Quantity, Price} <- Cart].
[{bread, 4, 0.25, 0.05}]
```

2. 모나드 **(Haskell)**
    - 순수 함수 언어를 사용하면 변경 가능한 상태를 프로그램에 포함시킬 수 없으므로, 변경 가능한 상태가 허용되는 것처럼 보이게 만드는 구조물을 구축하기 위해서 모나드를 사용하여 함수를 합성함

3. 매칭 **(Prolog, Scala, Erlang, Clojure, Haskell)**
    - 매칭 기능을 사용하여 파싱, 분산 메시지 전달, 분해, 통합, XML 처리 등을 구현할 수 있음

4. 통합 **(Prolog)**
    - 프롤로그에서는 왼쪽에 있는 값과 오른쪽에 있는 값이 같도록 만들기 위해서 가능한 값들을 하나의 규칙으로 치환함
    
```prolog
concatenate([], List, List).
concatenate([Head|Tail1], List, [Head|Tail2]) :-
    concatenate(Tail1, List, Tail2).
```